package sample.model.asset;

import java.math.BigDecimal;
import java.util.*;

import javax.persistence.*;
import javax.validation.constraints.NotNull;

import lombok.*;
import sample.ActionStatusType;
import sample.context.Dto;
import sample.context.orm.*;
import sample.model.constraints.*;
import sample.model.constraints.Currency;
import sample.util.*;

/**
 * Account activity cashflow.
 * The cashflow is account activity information of the decision state generated by a cashflow action
 *  such as the transfer (without the request cancellation).
 * low: The minimum columns with this sample
 */
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
@NamedQueries({
        @NamedQuery(name = "Cashflow.findDoRealize", query = "from Cashflow c where c.valueDay=?1 and c.statusType in ?2 order by c.id"),
        @NamedQuery(name = "Cashflow.findUnrealize", query = "from Cashflow c where c.accountId=?1 and c.currency=?2 and c.valueDay<=?3 and c.statusType in ?4 order by c.id") })
public class Cashflow extends JpaActiveRecord<Cashflow> {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue
    private Long id;
    @AccountId
    private String accountId;
    @Currency
    private String currency;
    @Amount
    private BigDecimal amount;
    @Enumerated(EnumType.STRING)
    @NotNull
    private CashflowType cashflowType;
    @Category
    private String remark;
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "day", column = @Column(name = "event_day")),
            @AttributeOverride(name = "date", column = @Column(name = "event_date")) })
    @NotNull
    private TimePoint eventDate;
    @Day
    private String valueDay;
    @Enumerated(EnumType.STRING)
    @NotNull
    private ActionStatusType statusType;
    @AccountId
    private String updateActor;
    @NotNull
    private Date updateDate;

    /** Make cashflow processed and reflect it to the balance. */
    public Cashflow realize(final JpaRepository rep) {
        TimePoint now = rep.dh().time().tp();
        Validator v = validator();
        v.verify(canRealize(rep), "error.Cashflow.realizeDay");
        v.verify(statusType.isUnprocessing(), "error.ActionStatusType.unprocessing"); // 「既に処理中/処理済です」

        setStatusType(ActionStatusType.PROCESSED);
        setUpdateActor(rep.dh().actor().getId());
        setUpdateDate(now.getDate());
        update(rep);
        CashBalance.getOrNew(rep, accountId, currency).add(rep, amount);
        return this;
    }

    /**
     * Mark error status.
     * low: Actually, Take error reasons in an argument and maintain it.
     */
    public Cashflow error(final JpaRepository rep) {
        validator().verify(statusType.isUnprocessed(), "error.ActionStatusType.unprocessing");

        setStatusType(ActionStatusType.ERROR);
        setUpdateActor(rep.dh().actor().getId());
        setUpdateDate(rep.dh().time().date());
        return update(rep);
    }

    public boolean canRealize(final JpaRepository rep) {
        return rep.dh().time().tp().afterEqualsDay(valueDay);
    }

    public static Cashflow load(final JpaRepository rep, Long id) {
        return rep.load(Cashflow.class, id);
    }

    public static List<Cashflow> findUnrealize(final JpaRepository rep, String accountId, String currency,
            String valueDay) {
        return rep.tmpl().find("Cashflow.findUnrealize", accountId, currency, valueDay,
                ActionStatusType.unprocessedTypes);
    }

    public static List<Cashflow> findDoRealize(final JpaRepository rep, String valueDay) {
        return rep.tmpl().find("Cashflow.findDoRealize", valueDay, ActionStatusType.unprocessedTypes);
    }

    /**
     * Register cashflow.
     * <p>Reached a value day, just reflect it to the balance.
     */
    public static Cashflow register(final JpaRepository rep, final RegCashflow p) {
        TimePoint now = rep.dh().time().tp();
        Validator v = new Validator();
        v.checkField(now.beforeEqualsDay(p.getValueDay()),
                "valueDay", "error.Cashflow.beforeEqualsDay");
        v.verify();
        Cashflow cf = p.create(now, rep.dh().actor().getId()).save(rep);
        return cf.canRealize(rep) ? cf.realize(rep) : cf;
    }

    /** Cashflow types. */
    public static enum CashflowType {
        CashIn,
        CashOut,
        CashTransferIn,
        CashTransferOut
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RegCashflow implements Dto {
        private static final long serialVersionUID = 1L;
        @AccountId
        private String accountId;
        @Currency
        private String currency;
        @Amount
        private BigDecimal amount;
        @NotNull
        private CashflowType cashflowType;
        @Category
        private String remark;
        @DayEmpty
        private String eventDay;
        @Day
        private String valueDay;

        public Cashflow create(final TimePoint now, String updActor) {
            TimePoint eventDate = eventDay == null ? now : new TimePoint(eventDay, now.getDate());
            return new Cashflow(null, accountId, currency, amount, cashflowType, remark, eventDate, valueDay,
                    ActionStatusType.UNPROCESSED, updActor, now.getDate());
        }
    }

}
